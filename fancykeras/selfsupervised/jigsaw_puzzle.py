# AUTOGENERATED! DO NOT EDIT! File to edit: ../../Notebooks/01_SelfSupervised/01_00_jigsaw_puzzle.ipynb.

# %% auto 0
__all__ = ['JigsawPuzzle']

# %% ../../Notebooks/01_SelfSupervised/01_00_jigsaw_puzzle.ipynb 3
from itertools import permutations

import numpy as np
from einops import rearrange
import tensorflow as tf

# %% ../../Notebooks/01_SelfSupervised/01_00_jigsaw_puzzle.ipynb 5
class JigsawPuzzle():
    """Class that supports all the logic needed to perform a jigsaw puzzle self-supervision task."""
    
    def __init__(self,
                 n_tiles, # Number of tiles per puzzle.
                 ):
        self.n_tiles = n_tiles
        self.permutations = list(permutations(range(n_tiles)))
        self.labels = list(range(len(self.permutations)))
        self.permutations2labels = {perm:label for perm, label in zip(self.permutations, self.labels)}
        self.labels2permutations = {label:perm for perm, label in zip(self.permutations, self.labels)}
    
    @property
    def possible_permutations(self):
        return len(self.permutations)

    def make_puzzle(self,
                    img, # Image we want to puzzle. (HxWxC)
                    ): # Puzzled image. (N_Tilesx(H/sqrt(N_Tiles))x(W/sqrt(N_Tiles))xC)
        """Takes as input an image and returns an array containing the puzzled image."""
        ## 1. Create patches
        h, w = img.shape[0:2]
        h_tile, w_tile = int(h) // int(np.sqrt(self.n_tiles)), int(w) // int(np.sqrt(self.n_tiles))
        puzzle = rearrange(img, "(h h2) (w w2) c -> (h w) h2 w2 c", h2=h_tile, w2=w_tile)

        ## 2. Obtain a random permutation
        idx = tf.random.categorical(tf.math.log([tf.ones(self.possible_permutations)/self.possible_permutations]), 1, dtype=tf.int32)[0][0]
        permutation = tf.gather(self.permutations, idx)
        permutation_label = tf.gather(self.labels, idx)
        ## 3. Rearrange the puzzle according to the permutation 
        puzzle = tf.gather(puzzle, indices=permutation)

        return puzzle, permutation_label
    
    def assemble_puzzle(self,
                        puzzle, # Puzzled image to be reassembled
                        ):
        return rearrange(puzzle, "(nh nw) h w c -> (nh h) (nw w) c", nh=self.n_tiles//2, nw=self.n_tiles//2)

    def invert_puzzle(self,
                      puzzle, # Puzzled image.
                      permutation, # Permutation used to create the puzzle.
                      return_full_image=True, # Wether to return the full image or an array of the separated tiles.
                      return_permutation=False, # Wether to return the permutation that inverses the original permutation or not.
                      ):
        """Takes a puzzle and the permutation that produced it and returns the de-puzzled image."""
        if not isinstance(permutation, np.ndarray): permutation = np.array(permutation)
        inv = np.empty_like(permutation)
        inv[permutation] = np.arange(permutation.shape[0])
        original_img = tf.gather(puzzle, inv)
        original_img = self.assemble_puzzle(original_img)
        if return_permutation: return original_img, inv
        else: return original_img
